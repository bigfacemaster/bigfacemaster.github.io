---
title: 重学算法第三期-60天攻克数据结构与算法-08
tags:
  - Algorithm
  - 算法
  - Data Structure
  - 数据结构
date: 2021-03-16 21:20:16
---

> [数据结构与算法之美](https://time.geekbang.org/column/intro/126)

# 学习内容 :递归：如何用三行代码找到“最终推荐人”？

> 递归（Recursion）(DFS深度优先搜索，前中后序二叉树遍历)

这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。

## 递归需要满足的三个条件

1. 一个问题的解可以分解为几个子问题的解；
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；
3. 存在递归终止条件。

## 如何编写递归代码？

> 写出递推公式，找到终止条件，转换成代码。

**写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。**

**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**



## 递归代码要警惕堆栈溢出

如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。

## 递归代码要警惕重复计算

为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。

在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。

## 怎么将递归代码改写为非递归代码？



递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。

